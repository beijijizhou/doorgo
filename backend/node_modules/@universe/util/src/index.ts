/* eslint-disable max-len */
/* global MessageChannel */
import * as nodeCrypto from 'node:crypto';
import type { MessageChannel as IMessageChannel } from 'worker_threads';

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const IS_BROWSER = (typeof globalThis.window === 'object' && window.document) || (typeof globalThis.WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope);
const crypto = IS_BROWSER ? globalThis.crypto : nodeCrypto;

// Generics type checking utils.
export const isNull = (v: unknown): v is null => v === null;
export const isString = (v: unknown): v is string => typeof v === 'string';
export const isStringOrNull = (v: unknown): v is string | null => isString(v) || isNull(v);
export const isBoolean = (v: unknown): v is boolean => typeof v === 'boolean';
export const isBooleanOrNull = (v: unknown): v is boolean | null => isBoolean(v) || isNull(v);
export const isNumber = (v: unknown): v is number => typeof v === 'number';
export const isNumberOrNull = (v: unknown): v is number | null => isNumber(v) || isNull(v);
export const isDate = (v: unknown): v is Date => v instanceof Date;
export const isDateOrNull = (v: unknown): v is Date | null => isDate(v) || isNull(v);
export const isObject = (o: unknown): o is Record<string, unknown> => !!(o && typeof o === 'object');
export const isObjectOrNull = (o: unknown): o is Record<string, unknown> => isObject(o) || isNull(o);
export const isArray = Array.isArray;
export const isArrayOrNull = (a: unknown): a is unknown[] => isArray(a) || isNull(a);

/* eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-explicit-any */
export const noop = (..._: any[]): void => {};
export const identityFunction = <T = unknown>(arg: T): T => arg;
export const assertNever = (message: string): never => { throw new Error(message); };

/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
// Itty bitty jquery clone
export class DomUtils<E extends HTMLElement> {
  private s: E[];
  constructor(s: string) { this.s = Array.from(document.querySelectorAll(s)); }
  el(n: number): E { return this.s[n]; }
  on(type: string, fn: EventListener, bubble = false) { for (const i of this.s) i.addEventListener(type, fn, bubble); return this; }
  off(type: string, fn: EventListener, bubble = false) { for (const i of this.s) i.addEventListener(type, fn, bubble); return this; }
  css(v: string) { for (const i of this.s) i.style.cssText = i.style.cssText + v; return this; }
  html(v: string) { for (const i of this.s) i.innerHTML = v; return this; }
  insertBefore(v: string) { for (const i of this.s) i.insertAdjacentHTML('beforebegin', v); return this; }
  insertAfter(v: string) { for (const i of this.s) i.insertAdjacentHTML('afterend', v); return this; }
  insertFirst(v: string) { for (const i of this.s) i.insertAdjacentHTML('afterbegin', v); return this; }
  insertLast(v: string) { for (const i of this.s) i.insertAdjacentHTML('beforeend', v); return this; }
  text(v: string) { for (const i of this.s) i.innerText = v; return this; }
  addClass(v: string) { for (const i of this.s) i.classList.add(v); return this; }
  toggleClass(v: string) { for (const i of this.s) i.classList.toggle(v); return this; }
  removeClass(v: string) { for (const i of this.s) i.classList.remove(v); return this; }
  empty() { for (const i of this.s) while (i.hasChildNodes()) i.lastChild && i.removeChild(i.lastChild); return this; }
  attr(a: string, v: string) { for (const i of this.s) i.setAttribute(a, v); return this; }
  getAttr(v: string) { return this.s[0].getAttribute(v); }
  removeAttr(v: string) { for (const i of this.s) i.removeAttribute(v); return this; }
  parent() { return this.s[0].parentNode; }
}
/* eslint-enable @typescript-eslint/explicit-module-boundary-types */

export const $ = <E extends HTMLElement = HTMLElement>(s: string): DomUtils<E> => new DomUtils<E>(s);

/* eslint-disable-next-line @typescript-eslint/no-empty-interface, no-use-before-define */
export type JsonArray = Array<string|number|boolean|null|Date|Json|JsonArray>
export interface Json { [x: string]: string|number|boolean|null|Date|Json|JsonArray }

// Cross environment utility functions.
const btoa = IS_BROWSER ? globalThis.btoa : (str: string) => Buffer.from(str, 'utf8').toString('base64');
const atob = IS_BROWSER ? globalThis.atob : (str: string) => Buffer.from(str, 'base64').toString('utf8');

const rand = (crypto as Crypto).getRandomValues?.bind(crypto) || nodeCrypto.randomFillSync;

// https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
const uuidValidator = /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i;
const TMPL_UUID = (`${  1e7  }${-1e3  }${-4e3  }${-8e3  }${-1e11}`);
export const NIL_UUID = '00000000-0000-0000-0000-000000000000';
export const isUuid = (v: unknown): v is string => isString(v) && (v === NIL_UUID || uuidValidator.test(v));
/* eslint-disable-next-line */
/* @ts-ignore-next-line */
export const uuid: (() => string) = crypto?.randomUUID?.bind(crypto) || ((): string => TMPL_UUID.replace(/[018]/g, c => (+c ^ rand(new Uint8Array(1))[0] & 15 >> +c / 4).toString(16)));

// Encodes a uuid4 into Base85 for size savings.
// Implements http://rfc.zeromq.org/spec:32
/* eslint-disable-next-line */
const decoder = [0x00, 0x44, 0x00, 0x54, 0x53, 0x52, 0x48, 0x00, 0x4B, 0x4C, 0x46, 0x41, 0x00, 0x3F, 0x3E, 0x45, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x40, 0x00, 0x49, 0x42, 0x4A, 0x47, 0x51, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x4D, 0x00, 0x4E, 0x43, 0x00, 0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x4F, 0x00, 0x50, 0x00, 0x00 ];
const encoder = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#'.split('');
export function base85UuidEncode(uuid: string): string {
  const data = Buffer.from(uuid.replace(/-/g, ''), 'hex');
  let str = '';
  let byteNumber = 0;
  let value = 0;
  while (byteNumber < data.length) {
    value = (value * 256) + data[byteNumber++];
    if ((byteNumber % 4) === 0) {
      let divisor = 52200625; // 85 * 85 * 85 * 85;
      while (divisor >= 1) {
        str += encoder[Math.floor(value / divisor) % 85];
        divisor /= 85;
      }
      value = 0;
    }
  }
  return str;
}

// Inspiration from https://stackoverflow.com/questions/34309988/byte-array-to-hex-string-conversion-in-javascript
const chars = new Uint8Array(36); // No need to keep re-creating this, we fully overwrite it every time as we compute! Share the memory for perf.
const utf8decoder = new TextDecoder('utf-8');
export function base85UuidDecode(data: string): string | null {
  let byteNumber = 0;
  let charNumber = 0;
  let hexCharNum = 0;
  let char = 0;
  let value = 0;
  let byte = 0;
  let nibble = 0;
  let divisor = 0;
  if ((data.length % 5) !== 0) { return null; }
  while (charNumber < data.length) {
    char = data.charCodeAt(charNumber++) - 32;
    if (char < 0 || char >= 96) { return null; } // 96 is decoder.length
    value = (value * 85) + decoder[char];
    if ((charNumber % 5) === 0) {
      divisor = 16777216; // 256 * 256 * 256;
      while (divisor >= 1) {
        byte = (value / divisor) & 0xFF; // Magic bitwise operator for % 256. 3x as fast.
        divisor = divisor >>> 8; // Bitwise operator for / 256
        nibble = byte >>> 4;
        chars[hexCharNum++] = nibble + (nibble > 9 ? 87 : 48); // 87 is the beginning of alphanumeric, 48 is 0.
        nibble = byte & 0xF;
        chars[hexCharNum++] = nibble + (nibble > 9 ? 87 : 48);
        if (byteNumber === 3 || byteNumber === 5 || byteNumber === 7 || byteNumber === 9) {
          chars[hexCharNum++] = 45; // Dash character
        }
        byteNumber++;
      }
      value = 0;
    }
  }

  // Hard coding is twice as fast as .apply() or spread.
  return utf8decoder.decode(chars);
  // return String.fromCharCode(
  //   chars[0], chars[1], chars[2], chars[3], chars[4], chars[5], chars[6], chars[7], chars[8], chars[9],
  //   chars[10], chars[11], chars[12], chars[13], chars[14], chars[15], chars[16], chars[17], chars[18], chars[19],
  //   chars[20], chars[21], chars[22], chars[23], chars[24], chars[25], chars[26], chars[27], chars[28], chars[29],
  //   chars[30], chars[31], chars[32], chars[33], chars[34], chars[35],
  // );
}

// URL Safe Base64 Encode/Decode
export const base64UrlEncode = (str: string): string => btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
export const base64UrlDecode = (str: string): string => atob(str.replace(/-/g, '+').replace(/_/g, '/'));

export const GET = <O>(url: string, headers = {}): Promise<O> => globalThis.fetch(url, { method: 'GET', headers }).then(async(res) => ((await res.json()) as O));
export const POST = <O>(url: string, data: Json = {}, headers = {}): Promise<O> => globalThis.fetch(url, {
  method: 'POST',
  headers: { Accept: 'application/json, text/plain, */*', 'Content-Type': 'application/json', ...headers },
  body: JSON.stringify(data),
}).then(async(res) => ((await res.json()) as O));

/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export const debounce = <F extends (...args: any) => any>(func: F, timeout: number): (this: ThisParameterType<F>, ...args: Parameters<F>) => Promise<ReturnType<F>> => {
  let ref: NodeJS.Timeout | null = null;
  let promise: Promise<ReturnType<F>> | null = null;
  let finish: ((val: ReturnType<F>) => void) | null = null;
  return function(this: ThisParameterType<F>, ...args: Parameters<F>): Promise<ReturnType<F>> {
    promise = promise || new Promise((resolve) => finish = resolve);
    ref && clearTimeout(ref);
    ref = setTimeout(() => {
      const resolve = finish;
      promise = ref = finish = null;
      ref = null;
      finish = null;
      const res = func.apply(this, args);
      resolve && resolve(res);
    }, timeout);
    return promise;
  };
};

// Thanks to:
// http://fightingforalostcause.net/misc/2006/compare-email-regex.php
// http://thedailywtf.com/Articles/Validating_Email_Addresses.aspx
// http://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/201378#201378
// https://en.wikipedia.org/wiki/Email_address  The format of an email address is local-part@domain, where the
// local part may be up to 64 octets long and the domain may have a maximum of 255 octets.[4]
const EMAIL_TEST = /^[-!#$%&'*+/0-9=?A-Z^_a-z`{|}~](\.?[-!#$%&'*+/0-9=?A-Z^_a-z`{|}~])*@[a-zA-Z0-9](-*\.?[a-zA-Z0-9])*\.[a-zA-Z](-?[a-zA-Z0-9])+$/;
// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
export function validateEmail(email: any): email is string {
  if (typeof email !== 'string') { return false; }
  const [ acct = '', addr = '' ] = email.split('@') || [];
  if (!email || acct.length > 64 || addr.length > 255 || addr.split('.').some((part: string) => part.length > 63)) return false;
  return EMAIL_TEST.test(email);
}

// http://howardhinnant.github.io/date_algorithms.html#civil_from_days
// https://stackoverflow.com/questions/7136385/calculate-day-number-from-an-unix-timestamp-in-a-math-way
export function posixToDate(s: number): { month: number, day: number, year: number } {
  const z = (s / 86400000 + 719468) | 0;
  const era = ((z >= 0 ? z : z - 146096) / 146097) | 0;
  const doe = z - era * 146097;
  const yoe = ((doe - ((doe / 1460) | 0) + ((doe / 36524) | 0) - ((doe / 146096) | 0)) / 365) | 0;
  const y = yoe + era * 400;
  const doy = doe - (365 * yoe + ((yoe / 4) | 0) - ((yoe / 100) | 0));
  const mp = ((5 * doy + 2) / 153) | 0;
  const d = doy - (((153 * mp + 2) / 5) | 0) + 1;
  const m = mp + (mp < 10 ? 3 : -9);
  return { month: m, day: d, year: y + +(m <= 2) };
}

export const abbrNum = function(num: number, fixed?: number): string | null {
  if (num === null) { return null; } // terminate early
  if (num === 0) { return '0'; } // terminate early
  fixed = (!fixed || fixed < 0) ? 0 : fixed; // number of decimal places to show
  const b = (num).toPrecision(2).split('e'); // get power
  const k = b.length === 1 ? 0 : Math.floor(Math.min(+b[1].slice(1), 14) / 3); // floor at decimals, ceiling at trillions
  const c = k < 1 ? num.toFixed(0 + fixed) : (num / Math.pow(10, k * 3)).toFixed(1 + fixed); // divide by power
  const d = +c < 0 ? c : Math.abs(+c); // enforce -0 is 0
  const e = d + [ '', 'K', 'M', 'B', 'T' ][k]; // append power
  return e;
};

export async function sha1Digest(message: string): Promise<string> {
  if (!IS_BROWSER && nodeCrypto.createHash) { return nodeCrypto.createHash('sha1').update(message, 'utf8').digest('hex'); }
  const msgUint8 = new TextEncoder().encode(message); // encode as (utf-8) Uint8Array
  const hashBuffer = await crypto.subtle.digest('SHA-1', msgUint8); // hash the message
  const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join(''); // convert bytes to hex string
}

export async function sha256Digest(message: string): Promise<string> {
  if (!IS_BROWSER && nodeCrypto.createHash) { return nodeCrypto.createHash('sha256').update(message, 'utf8').digest('hex'); }
  const msgUint8 = new TextEncoder().encode(message); // encode as (utf-8) Uint8Array
  const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8); // hash the message
  const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join(''); // convert bytes to hex string
}

// Ref: https://github.com/30-seconds/30-seconds-of-code
const STR_SPLIT_REG = /[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g;
export const toLowerCase = (str: string): string => String.prototype.toLowerCase.call(str);
export const toUpperCase = (str: string): string => String.prototype.toUpperCase.call(str);
export const toSnakeCase = (str: string): string => (str.match(STR_SPLIT_REG) || []).map(x => x.toLowerCase()).join('_');
export const toKebabCase = (str: string): string => (str.match(STR_SPLIT_REG) || []).map(x => x.toLowerCase()).join('-');
export const toTitleCase = (str: string): string => (str.match(STR_SPLIT_REG) || []).map(x => x.slice(0, 1).toUpperCase() + x.slice(1)).join(' ');
export const toPascalCase = (str: string): string => (str.match(STR_SPLIT_REG) || []).map(x => x.slice(0, 1).toUpperCase() + x.slice(1).toLowerCase()).join('');
export const toNameCase = (str: string): string => str.split('\'').map(str => str.split('-').map(s => s.split(' ').map(toPascalCase).join(' ')).join('-')).join('\'');
export const toCamelCase = (str: string): string => {
  const s = (str.match(STR_SPLIT_REG) || []).map(x => x.slice(0, 1).toUpperCase() + x.slice(1).toLowerCase()).join('');
  return s.slice(0, 1).toLowerCase() + s.slice(1);
};

export function idToHue(input: string, shift = 0): number {
  let out = 0;
  for (let i = 0; i < input.length; i++) { out += input[i].charCodeAt(0); }
  return (out + shift) % 255;
}

export function maxDate(...dates: (Date | number | null | undefined)[]): Date {
  return new Date(Math.max(...dates.map(d => +(d || 0))));
}

export async function lineCount(filePath: string): Promise<number> {
  if (IS_BROWSER) {
    throw new Error('[@universe/util] The lineCount function can only be used in a Node.js environment.');
  }
  /* eslint-disable-next-line */
  const fs = await import('fs');
  let lineCount = 0;
  return new Promise<number>((resolve) => {
    fs.createReadStream(filePath)
      .on('data', (chunk: string) => {
        let idx = -1;
        lineCount--; // Because the loop will run once for idx=-1
        do {
          idx = chunk.indexOf(String.fromCharCode(10), idx + 1);
          lineCount++;
        } while (idx !== -1);
      })
      .on('end', () => {
        resolve(lineCount);
      });
  });
}

// https://gist.github.com/MichaelPote/3f0cefaaa9578d7e30be
// http://www.myersdaily.org/joseph/javascript/md5-text.html
const HEX_CHR = '0123456789abcdef';
const cc = (a: string, n: number) => a.charCodeAt(n);
const rhex = (n: number): string => [ 0, 8, 16, 24 ].map(j => HEX_CHR[(n >> (j + 4)) & 0x0F] + HEX_CHR[(n >> j) & 0x0F]).join('');
const cmn = (q: number, a: number, b: number, x: number, s: number, t: number, c = ((a + q) >> 0) + ((x + t) >> 0)): number => ((((c >> 0) << s) | (c >> 0) >>> (32 - s)) + b) >> 0;
const ff = (a: number, b: number, c: number, d: number, x: number, s: number, t: number): number => cmn((b & c) | ((~b) & d), a, b, x, s, t);
const gg = (a: number, b: number, c: number, d: number, x: number, s: number, t: number): number => cmn((b & d) | (c & (~d)), a, b, x, s, t);
const hh = (a: number, b: number, c: number, d: number, x: number, s: number, t: number): number => cmn(b ^ c ^ d, a, b, x, s, t);
const ii = (a: number, b: number, c: number, d: number, x: number, s: number, t: number): number => cmn(c ^ (b | (~d)), a, b, x, s, t);

function md5cycle(x: number[], k: number[]): number[] {
  let [ a, b, c, d ] = x;
  a = ff(a, b, c, d, k[0], 7, -680876936);
  d = ff(d, a, b, c, k[1], 12, -389564586);
  c = ff(c, d, a, b, k[2], 17, 606105819);
  b = ff(b, c, d, a, k[3], 22, -1044525330);
  a = ff(a, b, c, d, k[4], 7, -176418897);
  d = ff(d, a, b, c, k[5], 12, 1200080426);
  c = ff(c, d, a, b, k[6], 17, -1473231341);
  b = ff(b, c, d, a, k[7], 22, -45705983);
  a = ff(a, b, c, d, k[8], 7, 1770035416);
  d = ff(d, a, b, c, k[9], 12, -1958414417);
  c = ff(c, d, a, b, k[10], 17, -42063);
  b = ff(b, c, d, a, k[11], 22, -1990404162);
  a = ff(a, b, c, d, k[12], 7, 1804603682);
  d = ff(d, a, b, c, k[13], 12, -40341101);
  c = ff(c, d, a, b, k[14], 17, -1502002290);
  b = ff(b, c, d, a, k[15], 22, 1236535329);
  a = gg(a, b, c, d, k[1], 5, -165796510);
  d = gg(d, a, b, c, k[6], 9, -1069501632);
  c = gg(c, d, a, b, k[11], 14, 643717713);
  b = gg(b, c, d, a, k[0], 20, -373897302);
  a = gg(a, b, c, d, k[5], 5, -701558691);
  d = gg(d, a, b, c, k[10], 9, 38016083);
  c = gg(c, d, a, b, k[15], 14, -660478335);
  b = gg(b, c, d, a, k[4], 20, -405537848);
  a = gg(a, b, c, d, k[9], 5, 568446438);
  d = gg(d, a, b, c, k[14], 9, -1019803690);
  c = gg(c, d, a, b, k[3], 14, -187363961);
  b = gg(b, c, d, a, k[8], 20, 1163531501);
  a = gg(a, b, c, d, k[13], 5, -1444681467);
  d = gg(d, a, b, c, k[2], 9, -51403784);
  c = gg(c, d, a, b, k[7], 14, 1735328473);
  b = gg(b, c, d, a, k[12], 20, -1926607734);
  a = hh(a, b, c, d, k[5], 4, -378558);
  d = hh(d, a, b, c, k[8], 11, -2022574463);
  c = hh(c, d, a, b, k[11], 16, 1839030562);
  b = hh(b, c, d, a, k[14], 23, -35309556);
  a = hh(a, b, c, d, k[1], 4, -1530992060);
  d = hh(d, a, b, c, k[4], 11, 1272893353);
  c = hh(c, d, a, b, k[7], 16, -155497632);
  b = hh(b, c, d, a, k[10], 23, -1094730640);
  a = hh(a, b, c, d, k[13], 4, 681279174);
  d = hh(d, a, b, c, k[0], 11, -358537222);
  c = hh(c, d, a, b, k[3], 16, -722521979);
  b = hh(b, c, d, a, k[6], 23, 76029189);
  a = hh(a, b, c, d, k[9], 4, -640364487);
  d = hh(d, a, b, c, k[12], 11, -421815835);
  c = hh(c, d, a, b, k[15], 16, 530742520);
  b = hh(b, c, d, a, k[2], 23, -995338651);
  a = ii(a, b, c, d, k[0], 6, -198630844);
  d = ii(d, a, b, c, k[7], 10, 1126891415);
  c = ii(c, d, a, b, k[14], 15, -1416354905);
  b = ii(b, c, d, a, k[5], 21, -57434055);
  a = ii(a, b, c, d, k[12], 6, 1700485571);
  d = ii(d, a, b, c, k[3], 10, -1894986606);
  c = ii(c, d, a, b, k[10], 15, -1051523);
  b = ii(b, c, d, a, k[1], 21, -2054922799);
  a = ii(a, b, c, d, k[8], 6, 1873313359);
  d = ii(d, a, b, c, k[15], 10, -30611744);
  c = ii(c, d, a, b, k[6], 15, -1560198380);
  b = ii(b, c, d, a, k[13], 21, 1309151649);
  a = ii(a, b, c, d, k[4], 6, -145523070);
  d = ii(d, a, b, c, k[11], 10, -1120210379);
  c = ii(c, d, a, b, k[2], 15, 718787259);
  b = ii(b, c, d, a, k[9], 21, -343485551);
  x[0] = (a + x[0]) >> 0;
  x[1] = (b + x[1]) >> 0;
  x[2] = (c + x[2]) >> 0;
  x[3] = (d + x[3]) >> 0;
  return x;
}

export function md5(s: string): string {
  /* eslint-disable-next-line @typescript-eslint/no-var-requires */
  if (!IS_BROWSER && nodeCrypto.createHash) { return nodeCrypto.createHash('md5').update(s, 'binary').digest('hex'); }
  const n = s.length;
  const state = [ 1732584193, -271733879, -1732584194, 271733878 ];
  const tail = new Array(16).fill(0);
  const fit = ((n / 64) | 0) * 64;
  for (let i = 0; i <= n - 64; i += 64) {
    md5cycle(state, tail.map((_, j) => cc(s, j * 4 + i) + (cc(s, j * 4 + i + 1) << 8) + (cc(s, j * 4 + i + 2) << 16) + (cc(s, j * 4 + i + 3) << 24)));
  }
  for (let i = 0; i < n - fit; i++) {
    tail[i >> 2] |= cc(s, i + fit) << ((i % 4) << 3);
  }
  tail[(n - fit) >> 2] |= 0x80 << (((n - fit) % 4) << 3);
  (n - fit) > 55 && md5cycle(state, tail.fill(0));
  tail[14] = n * 8;
  return md5cycle(state, tail).map(rhex).join('');
}

export function relativeDate(input: Date | number): string {
  const date = typeof input === 'number' ? new Date(input) : input;
  const diff = (((new Date()).getTime() - date.getTime()) / 1000);
  const dayDiff = Math.floor(diff / 86400);
  if (isNaN(dayDiff) || dayDiff < 0 || dayDiff >= 31) { return date.toLocaleDateString('en-us', { year: 'numeric', month: 'short', day: 'numeric' }); }
  if (diff < 60) return 'just now';
  if (diff < 120) return '1 minute ago';
  if (diff < 3600) return `${Math.floor(diff / 60)  } minutes ago`;
  if (diff < 7200) return '1 hour ago';
  if (diff < 86400) return `${Math.floor(diff / 3600)  } hours ago`;
  if (dayDiff === 1) return 'yesterday';
  if (dayDiff < 7) return `${dayDiff  } days ago`;
  if (dayDiff < 31) return `${Math.ceil(dayDiff / 7)  } weeks ago`;
  return '';
}

/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
const cloneCallbacks: Map<number, ((dat: any) => void)> = new Map();
let messageChannel: (IMessageChannel & { mid: number });
const resolveClone = (message: { mid: number; data: Record<string, unknown>}) => {
  const cb = cloneCallbacks.get(message.mid);
  cloneCallbacks.delete(message.mid);
  cb && cb(message.data);
};

// Use native V8 structured clone through worker thread message channels.
export const deepClone = async<T>(data: T): Promise<T> => {
  if (typeof data !== 'object') { return data; }
  if (!data) { return data; }

  if (!IS_BROWSER) {
    // In Node.js it works better to re-use the same message channel. If we re-create the message channel for every clone
    // like in the browser it actually duplicates ALL objects (including primitives like strings) when passing it from one
    // context to the next. In high-load situations this puts a lot of pressure on the garbage collector and results in massive
    // memory spikes.
    if (!messageChannel) {
      /* eslint-disable-next-line @typescript-eslint/no-var-requires */
      messageChannel = new ((await import('worker_threads')).MessageChannel as typeof IMessageChannel)() as IMessageChannel & { mid: number; };
      messageChannel.mid = 0;
      messageChannel.port2.on('message', resolveClone);
      // Unref must be called after message listener bound to allow the process to exit normally. Must be done after message event binding.
      messageChannel.port1.unref();
      messageChannel.port2.unref();
    }
    return new Promise((resolve) => {
      cloneCallbacks.set(messageChannel.mid, resolve);
      messageChannel && messageChannel.port1.postMessage({ mid: messageChannel.mid, data });
      messageChannel.mid = messageChannel.mid + 1 % Number.MAX_SAFE_INTEGER;
    });
  }
  
    // In the browser its better to create a new message channel for each clone. It does not (for whatever reason...) have the
    // same primitive cloning overhead as Node.js, and because it is more sync under the hood, re-using th same message channel
    // actually causes a backup, crashing the browser in high-load situations.
    return new Promise((resolve) => {
      const { port1, port2 } = new MessageChannel();
      /* eslint-disable-next-line */
      // @ts-ignore
      port2.onmessage = (o) => resolve(o.data);
      port1.postMessage(data);
    });
  
};

// A deferred promise that can be externally resolved or rejected.
export class Deferred<T = void> extends Promise<T> {
  public resolve!: (value: T | PromiseLike<T>) => void;
  public reject!: (err: Error) => void;
  constructor() {
    let res!: (value: T | PromiseLike<T>) => void;
    let rej!: (err: Error) => void;
    super((resolve, reject) => { res = resolve; rej = reject; });
    this.resolve = res;
    this.reject = rej;
  }

  static get [Symbol.species](): typeof Promise { return Promise; }
  get [Symbol.toStringTag](): string { return 'Deferred'; }
}

export const localHourToUTC = (hour: number): number => {
  // Generate a new date in the local timezone that's set to the input hour.
  const now = new Date();
  const date = new Date(now.getFullYear(), now.getMonth(), now.getDate(), Math.trunc(hour));
  const utcHour = parseInt(Intl.DateTimeFormat(
    Intl.DateTimeFormat().resolvedOptions().locale,
    { hour: 'numeric', hour12: false, timeZone: 'UTC' },
  ).format(date), 10);

  // Return UTC hour plus percentage of minutes elapsed.
  return utcHour + Math.round((hour % 1) * 100) / 100;
};

export const utcHourToLocal = (hour: number): number => {
  // Generate a new date in UTC that's set to the input hour.
  const now = new Date();
  const date = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), Math.trunc(hour));
  const localHour = parseInt(Intl.DateTimeFormat(
    Intl.DateTimeFormat().resolvedOptions().locale,
    { hour: 'numeric', hour12: false, timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone },
  ).format(date), 10);

  // Return local hour plus percent age of minutes elapsed.
  return localHour + Math.round((hour % 1) * 100) / 100;
};

enum TimeZone {
  US_ALASKA = 'US/Alaska',
  US_ALEUTIAN = 'US/Aleutian',
  US_ARIZONA = 'US/Arizona',
  US_CENTRAL = 'US/Central',
  US_EAST_INDIANA = 'US/East-Indiana',
  US_EASTERN = 'US/Eastern',
  US_HAWAII = 'US/Hawaii',
  US_INDIANA_STARKE = 'US/Indiana-Starke',
  US_MICHIGAN = 'US/Michigan',
  US_MOUNTAIN = 'US/Mountain',
  US_PACIFIC = 'US/Pacific',
  US_SAMOA = 'US/Samoa',
  ETC_GMT = 'Etc/GMT', // Greenwich time
}

export function getTimezone(): TimeZone {
  const tmp = Intl.DateTimeFormat().resolvedOptions().timeZone;
  if (tmp in TimeZone) { return tmp as TimeZone; }

  switch(tmp) {
    case 'America/Anchorage':
      return TimeZone.US_ALASKA;
    case 'America/Adak':
      return TimeZone.US_ALEUTIAN;
    case 'America/Phoenix':
      return TimeZone.US_ARIZONA;
    case 'America/Chicago':
      return TimeZone.US_CENTRAL;
    case 'America/Indiana/Indianapolis':
      return TimeZone.US_EAST_INDIANA;
    case 'America/New_York':
      return TimeZone.US_EASTERN;
    case 'America/Indiana/Knox':
      return TimeZone.US_INDIANA_STARKE;
    case 'America/Detroit':
      return TimeZone.US_MICHIGAN;
    case 'America/Denver':
      return TimeZone.US_MOUNTAIN;
    case 'Pacific/Honolulu':
      return TimeZone.US_HAWAII;
    case 'America/Los_Angeles':
      return TimeZone.US_PACIFIC;
    case 'Pacific/Pago_Pago':
      return TimeZone.US_SAMOA;
    default:
      return TimeZone.US_PACIFIC;
  }
}