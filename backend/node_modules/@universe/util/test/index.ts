/* global describe, it */
import * as assert from 'assert';
import * as fs from 'fs';
import * as path from 'path';

import {
  base64UrlDecode,
  base64UrlEncode,
  base85UuidDecode,
  base85UuidEncode,
  debounce,
  deepClone,
  Deferred,
  isUuid,
  localHourToUTC,
  md5,
  posixToDate,
  toCamelCase,
  toKebabCase,
  toLowerCase,
  toNameCase,
  toPascalCase,
  toSnakeCase,
  toTitleCase,
  toUpperCase,
  utcHourToLocal,
  uuid,
  validateEmail,
} from '../src/index';

describe('Utils', () => {
  describe('debounce should', () => {
    it('delay a call', async() => {
      const first = Date.now();
      let second = 0;
      await debounce(() => second = Date.now(), 1000)();
      assert.ok(second - first >= 1000);
    });
    it('only call the function once', async() => {
      const first = Date.now();
      let second = 0;
      let count = 0;
      const func = debounce(() => {
        count++;
        second = Date.now();
      }, 1200);
      func();
      func();
      func();
      await func();
      assert.ok(second - first >= 1000);
      assert.strictEqual(count, 1);
    });
    it('no debounce memory leak', async function() {
      this.timeout(120000);
      const func = debounce((arr: number[]) => {
        arr[0] = arr[1];
      }, 1);
      const before = process.memoryUsage().heapUsed / 1024 / 1024;
      for (let i = 0; i < 2000; i++) {
        await func(new Array(1000000).fill(1));
      }
      global?.gc?.();
      await new Promise(resolve => setTimeout(resolve, 3000));
      const after = process.memoryUsage().heapUsed / 1024 / 1024;
      assert.ok(after <= before, 'memory usage does not grow with many debounce calls');
    });
  });

  it('runs md5', () => {
    assert.strictEqual(md5('hello'), '5d41402abc4b2a76b9719d911017c592');
    assert.strictEqual(md5('0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'), 'c1906fa4ec71ebdc02c49c5d19908a39');
    assert.strictEqual(md5(fs.readFileSync(path.join(__dirname, '../../../fixtures/share.jpg'), 'binary')), '7b55446ad872973c5db5006905cc92aa');
  });

  it('runs base64Url', () => {
    assert.strictEqual(base64UrlEncode('Adam Miller'), 'QWRhbSBNaWxsZXI');
    assert.strictEqual(base64UrlDecode(base64UrlEncode('Adam Miller')), 'Adam Miller');

    assert.strictEqual(base64UrlEncode('Kelly'), 'S2VsbHk');
    assert.strictEqual(base64UrlDecode(base64UrlEncode('Kelly')), 'Kelly');
  });

  it('runs base85UuidEncode / base85UuidEncode', () => {
    const id = '1d0d0699-7002-4273-b013-2a963852c388';
    const encoded = base85UuidEncode(id);
    assert.strictEqual(isUuid(id), true);
    assert.strictEqual(encoded.length, 20);
    assert.strictEqual(base85UuidDecode(encoded), id);
    for (let i = 0; i < 2000; i++) {
      const id = uuid();
      const encoded = base85UuidEncode(id);
      assert.strictEqual(isUuid(id), true);
      assert.strictEqual(encoded.length, 20);
      assert.strictEqual(base85UuidDecode(encoded), id);
    }
  });

  it('validates emails', () => {
    assert.ok(validateEmail('adam@universe.app'));
    assert.ok(validateEmail('adam+tag@universe.app'));
    assert.ok(!validateEmail('@universe.app'));
    assert.ok(!validateEmail('adam@universe'));
    assert.ok(!validateEmail('adam@universe.'));
    assert.ok(!validateEmail('superduperlongemailaddressthatistechnicallynotallowedsuperduperlongemailaddressthatistechnicallynotallowed@universe.app'));
    assert.ok(!validateEmail('INVALID'));
    assert.ok(!validateEmail(false));
    assert.ok(!validateEmail(100));
    assert.ok(!validateEmail(new Date()));
    assert.ok(!validateEmail({}));
  });

  it('deep clones', async() => {
    const obj = {
      a: 1,
      b: { c: 3 },
      d: [ 1, 2, { e: 5 }],
    };
    const clone = await deepClone(obj);
    assert.notStrictEqual(obj, clone);
    assert.deepStrictEqual(obj, clone);
  });

  it('converts posix to date', async() => {
    const dates = [
      '6/29/1991',
      '1/1/1900',
      '1/1/3030',
      '12/31/1845',
      '12/31/7082',
      '6/1/2009',
      '6/29/2009',
    ];
    for (const date of dates) {
      const res = posixToDate(+(new Date(date)));
      assert.strictEqual(`${res.month}/${res.day}/${res.year}`, date);
    }
  });

  describe('deferrable should', () => {
    it('resolve', async() => {
      let runs = false;
      const deferrable = new Deferred<number>();
      const promise = deferrable.then((res) => {
        runs = true;
        assert.strictEqual(1, res);
      });
      deferrable.resolve(1);
      await promise;
      assert.strictEqual(true, runs);
    });

    it('reject', async() => {
      let runs = false;
      const deferrable = new Deferred<number>();
      const promise = deferrable.catch((err) => {
        runs = true;
        assert.strictEqual('Test', err.message);
      });
      deferrable.reject(new Error('Test'));
      await promise;
      assert.strictEqual(true, runs);
    });
  });

  describe('string methods should', () => {
    it('run toLowerCase', () => {
      assert.strictEqual(toLowerCase('WORKS'), 'works');
      assert.strictEqual(toLowerCase('works'), 'works');
      assert.strictEqual(toLowerCase('WoRkz 4-A c0^^P13X sTRing'), 'workz 4-a c0^^p13x string');
    });

    it('run toUpperCase', () => {
      assert.strictEqual(toUpperCase('WORKS'), 'WORKS');
      assert.strictEqual(toUpperCase('works'), 'WORKS');
      assert.strictEqual(toUpperCase('WoRkz 4-A c0^^P13X sTRing'), 'WORKZ 4-A C0^^P13X STRING');
    });

    it('run toSnakeCase', () => {
      assert.strictEqual(toSnakeCase('WORKS'), 'works');
      assert.strictEqual(toSnakeCase('works'), 'works');
      assert.strictEqual(toSnakeCase('WoRkz 4-A c0^^P13X sTRing'), 'wo_rkz_4_a_c0_p_13_x_s_t_ring');
      assert.strictEqual(toSnakeCase('kebab-case'), 'kebab_case');
      assert.strictEqual(toSnakeCase('snake_case'), 'snake_case');
      assert.strictEqual(toSnakeCase('Title Case'), 'title_case');
      assert.strictEqual(toSnakeCase('PascalCase'), 'pascal_case');
      assert.strictEqual(toSnakeCase('camalCase'), 'camal_case');
    });

    it('run toKebabCase', () => {
      assert.strictEqual(toKebabCase('WORKS'), 'works');
      assert.strictEqual(toKebabCase('works'), 'works');
      assert.strictEqual(toKebabCase('kebab-case'), 'kebab-case');
      assert.strictEqual(toKebabCase('snake_case'), 'snake-case');
      assert.strictEqual(toKebabCase('Title Case'), 'title-case');
      assert.strictEqual(toKebabCase('PascalCase'), 'pascal-case');
      assert.strictEqual(toKebabCase('camalCase'), 'camal-case');
    });

    it('run toTitleCase', () => {
      assert.strictEqual(toTitleCase('WORKS'), 'WORKS');
      assert.strictEqual(toTitleCase('works'), 'Works');
      assert.strictEqual(toTitleCase('kebab-case'), 'Kebab Case');
      assert.strictEqual(toTitleCase('snake_case'), 'Snake Case');
      assert.strictEqual(toTitleCase('Title Case'), 'Title Case');
      assert.strictEqual(toTitleCase('PascalCase'), 'Pascal Case');
      assert.strictEqual(toTitleCase('camalCase'), 'Camal Case');
    });

    it('run toPascalCase', () => {
      assert.strictEqual(toPascalCase('WORKS'), 'Works');
      assert.strictEqual(toPascalCase('works'), 'Works');
      assert.strictEqual(toPascalCase('kebab-case'), 'KebabCase');
      assert.strictEqual(toPascalCase('snake_case'), 'SnakeCase');
      assert.strictEqual(toPascalCase('Title Case'), 'TitleCase');
      assert.strictEqual(toPascalCase('PascalCase'), 'PascalCase');
      assert.strictEqual(toPascalCase('camalCase'), 'CamalCase');
    });

    it('run toCamelCase', () => {
      assert.strictEqual(toCamelCase('WORKS'), 'works');
      assert.strictEqual(toCamelCase('works'), 'works');
      assert.strictEqual(toCamelCase('kebab-case'), 'kebabCase');
      assert.strictEqual(toCamelCase('snake_case'), 'snakeCase');
      assert.strictEqual(toCamelCase('Title Case'), 'titleCase');
      assert.strictEqual(toCamelCase('PascalCase'), 'pascalCase');
      assert.strictEqual(toCamelCase('camalCase'), 'camalCase');
    });

    it('run toNameCase', () => {
      assert.strictEqual(toNameCase('WORKS'), 'Works');
      assert.strictEqual(toNameCase('works'), 'Works');
      assert.strictEqual(toNameCase('kebab-case'), 'Kebab-Case');
      assert.strictEqual(toNameCase('snake_case'), 'SnakeCase');
      assert.strictEqual(toNameCase('Title Case'), 'Title Case');
      assert.strictEqual(toNameCase('PascalCase'), 'PascalCase');
      assert.strictEqual(toNameCase('camalCase'), 'CamalCase');
      assert.strictEqual(toNameCase("o'Farrell"), "O'Farrell");
      assert.strictEqual(toNameCase('emily baker-white'), 'Emily Baker-White');
      assert.strictEqual(toNameCase('KellyRose fluty'), 'KellyRose Fluty');
    });
  });

  describe('Local Hours to UTC', () => {
    it('should convert local hours to utc while maintaining minutes elapsed', () => {
      assert.strictEqual(localHourToUTC(2.5), 10.5);
    });

    it('should convert local hours to utc while wrapping for the 24th hour mark', () => {
      assert.strictEqual(localHourToUTC(22.5), 6.5);
    });

    it('should convert local hours to utc', () => {
      assert.strictEqual(localHourToUTC(22), 6);
    });

    it('should convert utc hours to local while maintaining minutes elapsed', () => {
      assert.strictEqual(utcHourToLocal(2.5), 18.5);
    });

    it('should convert utc hours to local while wrapping for the 24th hour mark', () => {
      assert.strictEqual(utcHourToLocal(22.5), 14.5);
    });

    it('should convert utc hours to local', () => {
      assert.strictEqual(utcHourToLocal(22), 14);
    });
  });
});
